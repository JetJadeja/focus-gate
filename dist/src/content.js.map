{
  "version": 3,
  "sources": ["../../build/blob_animation.js", "../../build/util.js", "../../build/storage.js", "../../build/content.js"],
  "sourcesContent": ["// blob_animation.ts is a module which provides a class to easily instantiate the animations on the block page\r\nclass BlobElement {\r\n    constructor(x, y, r) {\r\n        this.fill = '#A6B1CE';\r\n        this.x = this.originalX = x;\r\n        this.y = this.originalY = y;\r\n        this.r = r || 10;\r\n        this.element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n        // set styling\r\n        this.element.setAttribute('r', this.r.toString());\r\n        this.element.setAttribute('style', `fill: ${this.fill};`);\r\n    }\r\n    // update element\r\n    update(mouseX, mouseY, repulsion, attraction) {\r\n        const dx = this.x - mouseX;\r\n        const dy = this.y - mouseY;\r\n        const angle = Math.atan2(dy, dx);\r\n        const dist = repulsion / Math.sqrt(dx * dx + dy * dy);\r\n        this.x += Math.cos(angle) * dist;\r\n        this.y += Math.sin(angle) * dist;\r\n        this.x += (this.originalX - this.x) * attraction;\r\n        this.y += (this.originalY - this.y) * attraction;\r\n        this.element.setAttribute('cx', this.x.toString());\r\n        this.element.setAttribute('cy', this.y.toString());\r\n    }\r\n}\r\nexport default class BlobAnimation {\r\n    constructor() {\r\n        this.config = {\r\n            blur: 8,\r\n            alphaMult: 30,\r\n            alphaAdd: -10,\r\n            numSeeds: 8,\r\n            childrenPerSeed: 3,\r\n            childrenDistanceRange: 100,\r\n            circleMinRadius: 15,\r\n            circleMaxRadius: 75,\r\n            attraction: 0.1,\r\n            repulsion: 1000,\r\n        };\r\n        this.animate = () => {\r\n            requestAnimationFrame(this.animate);\r\n            this.elements.forEach((e) => {\r\n                e.update(this.mouseX, this.mouseY, this.config.repulsion, this.config.attraction);\r\n            });\r\n        };\r\n        // grab dom elements\r\n        this.svg = document.getElementById('svg');\r\n        this.colorMatrixF = document.getElementById('colorMatrixF');\r\n        // bind event listeners\r\n        const body = document.getElementById('reflect-main');\r\n        window.addEventListener('resize', this.onResize, false);\r\n        body.addEventListener('mousemove', (e) => {\r\n            this.mouseX = e.clientX;\r\n            this.mouseY = e.clientY;\r\n        }, false);\r\n        body.addEventListener('mouseleave', this.resetMouse, false);\r\n        // create initial svg g elements\r\n        this.onResize();\r\n        this.resetMouse();\r\n        this.initElements();\r\n        this.colorMatrixF.setAttribute('values', `1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 ${this.config.alphaMult} ${this.config.alphaAdd}`);\r\n    }\r\n    random(min, max) {\r\n        return min + Math.random() * (max - min);\r\n    }\r\n    randomRange(targ, range) {\r\n        return targ + (Math.random() * 2 - 1) * range;\r\n    }\r\n    initElements() {\r\n        // create group div with namespace\r\n        this.elements = [];\r\n        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        this.svg.appendChild(group);\r\n        // create seeds\r\n        for (let i = 0; i < this.config.numSeeds; i++) {\r\n            const e = new BlobElement(this.randomRange(this.centerX, this.width * 0.4), this.randomRange(this.centerY, this.height * 0.4), this.random(this.config.circleMinRadius, this.config.circleMaxRadius));\r\n            e.update(this.mouseX, this.mouseY, this.config.repulsion, this.config.attraction);\r\n            group.appendChild(e.element);\r\n            this.elements.push(e);\r\n        }\r\n        // add children to seeds\r\n        this.elements.forEach((e) => {\r\n            for (let j = 0; j < this.config.childrenPerSeed; j++) {\r\n                const child = new BlobElement(this.randomRange(e.x, this.config.childrenDistanceRange), this.randomRange(e.y, this.config.childrenDistanceRange), this.random(this.config.circleMinRadius, this.config.circleMaxRadius));\r\n                child.update(this.mouseX, this.mouseY, this.config.repulsion, this.config.attraction);\r\n                group.appendChild(child.element);\r\n                this.elements.push(child);\r\n            }\r\n        });\r\n    }\r\n    // set mouse cords back to bottom centre screen\r\n    resetMouse() {\r\n        this.mouseX = this.centerX;\r\n        this.mouseY = 5 * this.centerY;\r\n    }\r\n    // recompute width, height, and centre\r\n    onResize() {\r\n        this.width = window.innerWidth;\r\n        this.height = window.innerHeight;\r\n        this.centerX = this.width / 2;\r\n        this.centerY = this.height / 2;\r\n    }\r\n}\r\n", "// util.ts provides utility functions that can be reused in other modules\r\nexport function addMinutes(date, minutes) {\r\n    return new Date(date.getTime() + minutes * 60000);\r\n}\r\nexport function cleanDomain(urls) {\r\n    // check to see if urls exist\r\n    if (urls[0] === undefined) {\r\n        // return empty if not\r\n        return '';\r\n    }\r\n    else {\r\n        // regex match for url\r\n        const activeURL = urls[0].match(/^[\\w]+:\\/{2}([\\w\\.:-]+)/);\r\n        // no matching sites, return empty\r\n        if (activeURL == null) {\r\n            return '';\r\n        }\r\n        else {\r\n            // strip www.\r\n            return activeURL[1].replace('www.', '');\r\n        }\r\n    }\r\n}\r\n", "// storage.ts provides a thin wrapper around the chrome storage api to make it easier to read/write from it\r\n// you can also find helper functions that read/write to chrome storage\r\nimport { addMinutes } from './util';\r\n// helper function to retrive chrome storage object\r\n// usage:\r\n//\r\n// getStorage(null).then(storage => {\r\n//     ...\r\n// })\r\nexport function getStorage() {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.storage.sync.get(null, (storage) => {\r\n            if (chrome.runtime.lastError !== undefined) {\r\n                reject(chrome.runtime.lastError);\r\n            }\r\n            else {\r\n                resolve(storage);\r\n            }\r\n        });\r\n    });\r\n}\r\n// helper function to set fields in chrome storage\r\n// usage:\r\n//\r\n// getStorage({enableBlobs: false}).then(storage => {\r\n//     ...\r\n// })\r\nexport function setStorage(key) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.storage.sync.set(key, () => {\r\n            if (chrome.runtime.lastError !== undefined) {\r\n                reject(chrome.runtime.lastError);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\n// Add a single url to blocklist (does nothing if url is already in list)\r\nexport function addToBlocked(url, callback) {\r\n    getStorage().then((storage) => {\r\n        if (!storage.blockedSites.includes(url)) {\r\n            storage.blockedSites.push(url);\r\n            setStorage({ blockedSites: storage.blockedSites }).then(() => {\r\n                console.log(`${url} added to blocked sites`);\r\n                callback ? callback() : () => { };\r\n            });\r\n        }\r\n    });\r\n}\r\n// Remove single url from blocklist (does nothing if url is not in list)\r\nexport function removeFromBlocked(url) {\r\n    getStorage().then((storage) => {\r\n        let blockedSites = storage.blockedSites;\r\n        blockedSites = blockedSites.filter((e) => e !== url);\r\n        setStorage({ blockedSites: blockedSites }).then(() => {\r\n            console.log(`removed ${url} from blocked sites`);\r\n        });\r\n    });\r\n}\r\n// Add a single url to whitelist with associated whitelist duration\r\n// (replaces any existing entries)\r\nexport function addToWhitelist(url, minutes) {\r\n    getStorage().then((storage) => {\r\n        let whitelistedSites = storage.whitelistedSites;\r\n        let expiry = addMinutes(new Date(), minutes);\r\n        whitelistedSites[url] = expiry.toJSON();\r\n        setStorage({ whitelistedSites: whitelistedSites }).then(() => {\r\n            console.log(`${url} added to whitelisted sites`);\r\n        });\r\n    });\r\n}\r\nexport function logIntentToStorage(intentString, intentDate, url) {\r\n    getStorage().then((storage) => {\r\n        let intentList = storage.intentList;\r\n        // getting oldest date value from intent list map\r\n        let oldest_date = new Date();\r\n        for (const rawDate in intentList) {\r\n            const date = new Date(rawDate);\r\n            if (date < oldest_date) {\r\n                oldest_date = date;\r\n            }\r\n        }\r\n        // deleting oldest intent to keep intent count under limit\r\n        if (Object.keys(intentList).length > storage.numIntentEntries) {\r\n            console.log(`list full, popping ${oldest_date.toJSON()}`);\r\n            delete intentList[oldest_date.toJSON()];\r\n        }\r\n        // adding new intent and date to intent list\r\n        intentList[intentDate.toJSON()] = {\r\n            intent: intentString,\r\n            url: url,\r\n        };\r\n        // saving intentList to chrome storage\r\n        setStorage({ intentList: intentList }).then(() => {\r\n            console.log(`logged intent \"${intentString}\"`);\r\n        });\r\n    });\r\n}\r\n", "import BlobAnimation from './blob_animation';\r\nimport { getStorage, logIntentToStorage } from './storage';\r\nimport { cleanDomain } from './util';\r\n// some colour definitions\r\nconst REFLECT_INFO = '#576ca8';\r\nconst REFLECT_ERR = '#ff4a47';\r\n// as soon as page loads, check if we need to block it\r\ncheckIfBlocked();\r\n// re-check page everytime this page gets focus again\r\nwindow.addEventListener('focus', checkIfBlocked);\r\n// check to see if the current website needs to be blocked\r\nfunction checkIfBlocked() {\r\n    // if already on reflect page, don't need to re-block\r\n    if (!!document.getElementById('reflect-main')) {\r\n        return;\r\n    }\r\n    getStorage().then((storage) => {\r\n        console.log(storage);\r\n        if (!storage.isEnabled) {\r\n            return;\r\n        }\r\n        const strippedURL = getStrippedUrl();\r\n        // match current url against stored blocklist\r\n        storage.blockedSites.forEach((site) => {\r\n            if (strippedURL.includes(site) && !isWhitelistedWrapper()) {\r\n                // found a match, check if currently on whitelist\r\n                console.log('bro wtf just block this shit already');\r\n                iterWhitelist();\r\n            }\r\n        });\r\n    });\r\n}\r\n// display a message under intent entry field\r\nfunction displayStatus(message, duration = 3000, colour = REFLECT_INFO) {\r\n    $('#statusContent').css('color', colour);\r\n    $('#statusContent').text(message);\r\n    $('#statusContent').show().delay(duration).fadeOut();\r\n}\r\n// check to see if domain is whitelisted\r\nfunction isWhitelistedWrapper() {\r\n    const WHITELISTED_WRAPPERS = ['facebook.com/flx', 'l.facebook.com'];\r\n    return WHITELISTED_WRAPPERS.some((wrapper) => window.location.href.includes(wrapper));\r\n}\r\n// thin wrapper around util.ts/cleanDomain\r\nfunction getStrippedUrl() {\r\n    return cleanDomain([window.location.href]);\r\n}\r\nfunction iterWhitelist() {\r\n    // iterate whitelisted sites\r\n    getStorage().then((storage) => {\r\n        const strippedURL = getStrippedUrl();\r\n        if (strippedURL === '') {\r\n            return;\r\n        }\r\n        // get dictionary of whitelisted sites\r\n        const whitelist = storage.whitelistedSites;\r\n        // is current url whitelisted?\r\n        if (!whitelist.hasOwnProperty(strippedURL)) {\r\n            loadBlockPage(strippedURL);\r\n            return;\r\n        }\r\n        // check if whitelist period is expired\r\n        const parsedDate = new Date(whitelist[strippedURL]);\r\n        const currentDate = new Date();\r\n        const expired = currentDate >= parsedDate;\r\n        if (expired) {\r\n            loadBlockPage(strippedURL);\r\n            return;\r\n        }\r\n        const timeDifference = parsedDate.getTime() - currentDate.getTime();\r\n        // set timer to re-block page after whitelist period expires\r\n        setTimeout(() => {\r\n            loadBlockPage(strippedURL);\r\n        }, timeDifference);\r\n    });\r\n}\r\n// replace current page with reflect block page\r\nfunction loadBlockPage(strippedURL) {\r\n    const prompt_page_url = chrome.runtime.getURL('res/pages/prompt.html');\r\n    const options_page_url = chrome.runtime.getURL('res/pages/options.html');\r\n    getStorage().then((storage) => {\r\n        // get prompt page content\r\n        $.get(prompt_page_url, (page) => {\r\n            var _a;\r\n            // stop current page and replace with our blocker page\r\n            window.stop();\r\n            $('html').html(page);\r\n            addFormListener(strippedURL);\r\n            $('#linkToOptions').attr('href', options_page_url);\r\n            if (_a = storage.enableBlobs, (_a !== null && _a !== void 0 ? _a : true)) {\r\n                const anim = new BlobAnimation();\r\n                anim.animate();\r\n            }\r\n            //modify custom message based on user input\r\n            const welcome = document.getElementById('customMessageContent');\r\n            welcome.textContent = storage.customMessage;\r\n        });\r\n    });\r\n}\r\nfunction addFormListener(strippedURL) {\r\n    var _a;\r\n    const form = document.forms.namedItem('inputForm');\r\n    // add listener for form submit\r\n    (_a = form) === null || _a === void 0 ? void 0 : _a.addEventListener('submit', (event) => {\r\n        // prevent default submit\r\n        event.preventDefault();\r\n        // extract entry\r\n        const intentForm = event.target;\r\n        const intent = new FormData(intentForm).get('intent');\r\n        const intentString = intent.toString();\r\n        const intentDate = new Date();\r\n        callBackgroundWithIntent(intentString);\r\n        logIntentToStorage(intentString, intentDate, strippedURL);\r\n    });\r\n}\r\nfunction callBackgroundWithIntent(intent) {\r\n    // open connection to runtime (background.ts)\r\n    const port = chrome.runtime.connect({\r\n        name: 'intentStatus',\r\n    });\r\n    // send message then wait for response\r\n    port.postMessage({ intent: intent, url: window.location.href });\r\n    port.onMessage.addListener((msg) => {\r\n        switch (msg.status) {\r\n            case 'ok':\r\n                // show success message\r\n                getStorage().then((storage) => {\r\n                    const WHITELIST_PERIOD = storage.whitelistTime;\r\n                    displayStatus(`got it! ${WHITELIST_PERIOD} minutes starting now.`, 3000, REFLECT_INFO);\r\n                    location.reload();\r\n                });\r\n                break;\r\n            case 'too_short':\r\n                invalidIntent('your response is a little short. be more specific!');\r\n                break;\r\n            case 'invalid':\r\n                invalidIntent(\"that doesn't seem to be productive. try being more specific.\");\r\n                break;\r\n        }\r\n        // close connection\r\n        port.disconnect();\r\n    });\r\n}\r\nfunction invalidIntent(msg) {\r\n    $('#inputFields').effect('shake', { times: 3, distance: 5 });\r\n    displayStatus(msg, 3000, REFLECT_ERR);\r\n    $('#textbox').val('');\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
